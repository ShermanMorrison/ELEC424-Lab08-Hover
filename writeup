Lab07: PID tuning
Jonathan Wilson, Chase Stewart


Final PID values:

self.cfParams = {
    'pid_rate.pitch_kp': 90.0,
    'pid_rate.pitch_kd': 0.0,
    'pid_rate.pitch_ki': 15.0,
    'pid_rate.roll_kp': 100.0,
    'pid_rate.roll_kd': 0.0,
    'pid_rate.roll_ki': 15.0,
    'pid_rate.yaw_kp': 50.0,
    'pid_rate.yaw_kd': 23.0,
    'pid_rate.yaw_ki': 2.0,
    'pid_attitude.pitch_kp': 3.5,
    'pid_attitude.pitch_kd': 2.0,
    'pid_attitude.pitch_ki': 0.0,
    'pid_attitude.roll_kp': 3.5,
    'pid_attitude.roll_kd': 2.0,
    'pid_attitude.roll_ki': 0.0,
    'pid_attitude.yaw_kp': 0.0,
    'pid_attitude.yaw_kd': 0.0,
    'pid_attitude.yaw_ki': 0.0,
    'sensorfusion6.kp': 0.800000011921,
    'sensorfusion6.ki': 0.00200000009499,
    'imu_acc_lpf.factor': 32 }
Changes to Code:
First, we had to find a way to get the roll-pitch-yaw, so we could compute an error measure. To do this we added a setter to aicontroller.py, which we called in FlightTab.py when imu data was received (in _imu_data_received()).
We added logic in augmentInputwithAi() to try different values of the gains for a given number of trials, for each of roll, pitch, and yaw. We implemented pidTuner() to update the pid gains.

Approach to tuning the PID:

We started with pitch_kp at 50, roll_kp at 60, yaw_kp at 70, and all ki and kd gains at 0. We then determined the pitch_kp that gave the minimum error, holding the other gains constant. We repeated this process for roll_kp and yaw_kp, using the optimal kp's already calculated.
To set the ki and kd, we did some <CHASE MAGIC>.

<What interface does the controller signal use to determine motor thrust?>


Jonathan Wilson: 50%
Chase E. Stewart: 50%

